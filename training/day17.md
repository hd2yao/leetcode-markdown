# 🤬 day17

## 代码随想录算法训练营第十七天| 栈与队列 239

### 239 滑动窗口最大值

题目链接：[https://leetcode.cn/problems/sliding-window-maximum/](https://leetcode.cn/problems/sliding-window-maximum/)

文章讲解：[https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)

视频讲解：[https://www.bilibili.com/video/BV1XS4y1p7qj](https://www.bilibili.com/video/BV1XS4y1p7qj)

**思路**

一开始没什么思路，去瞄了一眼解析回来接着做，看到要使用队列来解决

那么对于这道题来说，队列的三个方法，根据窗口移动：

* 新元素入队列
* 首元素出队列
* 计算当前队列中的最大值

而我能想到的计算队列中的最大值就是遍历，然后果不出其然，超时了

出入队列都没什么问题，这道题的核心就在于如何计算最大值

\----------------------- （分界线）

单调队列

对于某一个窗口，更靠右且更大的值，更可能成为最大值的候选值，所以左边更小的元素就没有维护的必要，队列的出队口的元素就是当前队列中的最大值

> “更可能成为最大值的候选值” 这句话的理解
>
> 因为当前队列的出队口的元素是最大值，而随着窗口的移动，这个元素也是会从队列中弹出的

例如， 1,5,2,1,0,4, ...， k = 3

* 1,5,2

首先 1 入队，然后 5 比 1 大，所以不再维护这个 1 ，因为在长度为 3 的窗口中，1 不在可能是最大值，因此 1 出队，5 入队，此时出队口元素为 5。 后面 2 比 5 小，直接入队

* 5,2,1

同理，1 比 2 小，直接入队

* 2,1,0

此时，窗口移动，5 已不在窗口中，因此 5 出队，此时出队口元素就是 2，这里就可以理解上面 “更可能成为最大值的候选值”

当理解了这个过程，代码也就比较容易写出来了

注：

下面是 pop 中的代码，因为我自己写的时候，对下面这种写法不理解（语法上，不是代码理解），所以去查阅了一些资料，特在这里记录备注一下

```go
if !m.IsEmpty() && val == m.Front() {
    m.queue = m.queue[1:]
}
```

最初的疑问：

如果此时 slice 中只有一个元素，即 `len(m.queue) == 1`，`m.queue[1]` 会触发 panic，那么为什么 `m.queue[1:]` 就能够切出一个新的切片

查阅后：

在 Go 中，从一个切片末尾位置开始的切片操作是合法的。例如，一个切片 `s`，长度为 `n`，那么 `s[n:]` 将生成一个空切片。 这是因为切片操作 `s[start:end]` 允许 `start` 等于 `len(s)`，从而生成一个空切片，但不允许 `start` 超过 `len(s)`，否则同样会 panic

[完整代码](https://github.com/hd2yao/leetcode/tree/master/training/day17/0239\_sliding\_window\_maximum.go)
